
from sage.combinat.permutation import Permutation
from sage.misc.flatten import flatten
from sage.combinat.set_partition_ordered import OrderedSetPartitions
from permutation_set import PermutationSet
from static_permutation_set import StaticPermutationSet
from point import Point
from itertools import product

class GeneratingRule(PermutationSet):
    """A permutation set containing all permutations generated by a generating
    rule."""

    def __init__(self, rule):

        # self.rule = rule

        if type(rule) is list:
            self.rule = { (i,j): rule[i][j] for i in range(len(rule)) for j in range(len(rule[i])) if rule[i][j] is not None }
        else:
            self.rule = rule


    # When we implement generating_function, this is probably what it will
    # look like (this will not handle inputs in same row/col):
    # def generating_function(self):
    #     gf = 1
    #     for row in self.rule:
    #         for s in row:
    #             gf *= s.generating_function()
    #     gf += 1
    #     return gf

    def generate_of_length(self, n, input):

        rule = list(self.rule.items())
        h = max( k[0] for k,v in rule ) + 1
        w = max( k[1] for k,v in rule ) + 1

        def permute(arr, perm):
            res = [None] * len(arr)
            for i in range(len(arr)):
                res[i] = arr[perm[i] - 1]
            return res

        def count_assignments(at, left):

            if at == len(rule):
                if left == 0:
                    yield []
            elif type(rule[at][1]) is Point:
                # this doesn't need to be handled separately,
                # it's just an optimization
                if left > 0:
                    for ass in count_assignments(at + 1, left - 1):
                        yield [1] + ass
            else:
                for cur in range(left+1):
                    for ass in count_assignments(at + 1, left - cur):
                        yield [cur] + ass

        for count_ass in count_assignments(0, n):
            for perm_ass in product(*[ s[1].generate_of_length(cnt, input) for cnt, s in zip(count_ass, rule) ]):

                arr = [ [ Permutation([]) for j in range(w) ] for i in range(h) ]

                for i, perm in enumerate(perm_ass):
                    arr[rule[i][0][0]][rule[i][0][1]] = perm

                rowcnt = [ sum( len(arr[row][col]) for col in range(w) ) for row in range(h) ]
                colcnt = [ sum( len(arr[row][col]) for row in range(h) ) for col in range(w) ]

                for colpart in product(*[ OrderedSetPartitions(range(colcnt[col]), [ len(arr[row][col]) for row in range(h) ]) for col in range(w) ]):
                    for rowpart in product(*[ OrderedSetPartitions(range(rowcnt[row]), [ len(arr[row][col]) for col in range(w) ]) for row in range(h) ]):
                        res = [ [None]*colcnt[col] for col in range(w) ]

                        cumul = 1
                        for row in range(h-1,-1,-1):
                            for col in range(w):
                                for idx, val in zip(sorted(colpart[col][row]), permute(sorted(rowpart[row][col]), arr[row][col])):
                                    res[col][idx] = cumul + val

                            cumul += rowcnt[row]

                        yield Permutation(flatten(res))


    def to_static(self, max_n, input):

        inp = dict(input)

        for n in range(max_n+1):
            for perm in self.generate_of_length(n, inp):
                inp.setdefault(n, [])
                inp[n].append(perm)

        try:
            gf = self.generating_function()
        except NotImplementedError:
            gf = None

        perms = [ p for ps in inp.values() for p in ps ]
        return StaticPermutationSet(perms, gf)

