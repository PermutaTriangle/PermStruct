# This file was *autogenerated* from the file simple_input_rules.sage.
from sage.all_cmdline import *   # import sage library
_sage_const_3 = Integer(3); _sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_6 = Integer(6); _sage_const_4 = Integer(4)
import itertools


'''
A permutation of length s+t for a rule with s points and t unshaded
boxes. We "mark" the s points on the permutation to remember which correspond to points.
'''

def sumTs(n):
    
    return CartesianProduct(Permutations(n), Subsets(range(n)))

def createFromSumType( sumT, atoms, B, b = _sage_const_1 , permProp = (lambda perm : True), permCount = (lambda n : _sage_const_0 ), overl = (lambda n : _sage_const_1 ), compl = (lambda n: _sage_const_1 ), report = False ):
    
    created = {}
    
    # Putting the atoms in the dictionary by length
    for atom in atoms:
        created.setdefault(len(atom),[])
        created[len(atom)].append(atom)
    
    rulePerm  = sumT[_sage_const_0 ]
    nrulePerm = len(rulePerm)
    pts       = sumT[_sage_const_1 ]
    npts      = pts.cardinality()
    
    if npts == _sage_const_0 :
        if report:
            print "We do not currently support rules without points"
        return created
    
    rulePermInv = rulePerm.inverse()
    
    nfree = nrulePerm-npts
    
    for n in range(b, B+_sage_const_1 ):
        
        # Need to be careful if there are atoms of length n        
        created.setdefault(n,[])
        
        if nfree == _sage_const_0  and nrulePerm == n:
            created[n].append(rulePerm)
        
        for oPart in IntegerVectors(n - npts, nfree):
            
            for elt in itertools.product(*map( lambda x : created[x], oPart )):
                
                #print elt
                outPerm = [None]*nrulePerm
                
                cumul = _sage_const_0 
                used  = _sage_const_0 
                for ind in rulePermInv:
                    #print "ind", ind
                    
                    # if ind is marked
                    if ind-_sage_const_1  in pts:
                        cumul += _sage_const_1 
                        outPerm[ind-_sage_const_1 ] = cumul
                    else:
                        new = elt[used]
                        used += _sage_const_1 
                        outPerm[ind-_sage_const_1 ] = map( lambda x : x + cumul, new)
                        cumul += len(new)
                        
                outPerm = Permutation(flatten(outPerm))
                
                if not permProp(outPerm):
                    if report:
                        print "Generated the permutation ", outPerm, " which does not satisfy the property"
                    return {}
                        
                created[n].append(outPerm)
        
        if len(created[n]) < compl(n)*permCount(n):
            if report:
                print "The rule creates too few permutations of length ", n
            return {}
        
        if Set(created[n]).cardinality() < overl(n) * len(created[n]):
            if report:
                print "The rule is too overlapping"
            return {}
                
    return created

B = _sage_const_6 

permProp  = (lambda perm : perm.avoids([_sage_const_2 ,_sage_const_1 ,_sage_const_4 ,_sage_const_3 ]))
permCount = (lambda n : len(filter(lambda x : permProp(x), Permutations(n))) )
overl     = (lambda n : _sage_const_1 )
compl     = (lambda n : _sage_const_1 /_sage_const_4 )
atoms = [Permutation([])]

for N in range(_sage_const_1 ,_sage_const_6 ):
    for sumT in sumTs(N):
        #print sumT
        cr = createFromSumType( sumT, atoms, B, _sage_const_1 , permProp, permCount, overl, compl, report = False )
        if len(cr) > len(atoms):
            print sumT
            print cr
            print len(cr)
            print ""
