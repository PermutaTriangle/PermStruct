
from .permutation_set import PermutationSet
from .static_permutation_set import StaticPermutationSet
from .point_permutation_set import PointPermutationSet
from itertools import product
from copy import deepcopy

def flatten(lst):
    res = []
    def dfs(l):
        for i in l:
            if type(i) is list or type(i) is tuple:
                dfs(i)
            else:
                res.append(i)
    dfs(lst)
    return res

class SimpleGeneratingRule(PermutationSet):
    """A permutation set containing all permutations generated by a simple
    generating rule."""

    def __init__(self, perm, sets, description=None):
        super(SimpleGeneratingRule, self).__init__(description=description)

        self.perm = perm
        self.sets = sets

    # When we implement get_generating_function, this is probably what it will
    # look like:
    # def generating_function(self):
    #     gf = 1
    #     for s in sets:
    #         gf *= s.generating_function()

    #     gf += 1
    #     return gf

    def generate_of_length(self, n, input):

        def count_assignments(at, left):

            if at == len(self.perm):
                if left == 0:
                    yield []
            elif type(self.sets[at]) is PointPermutationSet:
                # this doesn't need to be handled separately,
                # it's just an optimization
                if left > 0:
                    for ass in count_assignments(at + 1, left - 1):
                        yield [1] + ass
            else:
                for cur in range(left+1):
                    for ass in count_assignments(at + 1, left - cur):
                        yield [cur] + ass

        permInv = self.perm.inverse()
        for count_ass in count_assignments(0, n):

            for perm_ass in product(*[ s.generate_of_length(cnt, input) for cnt, s in zip(count_ass, self.sets) ]):

                res = [None]*len(self.perm)
                cumul = 0
                for idx in permInv:
                    res[idx-1] = [ x + cumul for x in perm_ass[idx-1] ]
                    cumul += count_ass[idx-1]

                yield tuple(flatten(res))

    def to_static(self, max_n, input, description=None):

        inp = deepcopy(input)

        for n in range(max_n+1):
            for perm in self.generate_of_length(n, inp):
                inp.setdefault(n, [])
                inp[n].append(perm)

        try:
            gf = self.generating_function()
        except NotImplementedError:
            gf = None

        perms = [ p for ps in inp.values() for p in ps ]
        return StaticPermutationSet(perms, gf, description if description is not None else self.description)

